######### DATAlign Pipeline
###########################


######### Take all filenames ending in .fq.gz to make filenames reference list for all subsequent codes
ls *.fq.gz | cut -f 1 -d '.' > filenames
ls *.fq.gz | sed "s/_R1.*//" | sed "s/_R2.*//" | uniq > filenames_trim


######### Build and index database using bowtie2 - we will use the CARD and ICE.fasta file. But any one will work
bowtie2-build ICE_seq_all.fasta ICE_db
bowtie2-build CARD_mobile_merged.fasta ARG_db


######### Clean up the fq.gz files: trim and check for quality

# Trim fq files based on quality (Phred score 25) and length (149 nt) 
while read p; do java -jar /opt/biotools/trimmomatic/trimmomatic-0.36.jar PE -phred33 "$p"_R1.fq.gz "$p"_R2.fq.gz "$p"_R1_paired.fq.gz "$p"_R1_unpaired.fq.gz "$p"_R2_paired.fq.gz "$p"_R2_unpaired.fq.gz ILLUMINACLIP:TruSeq3-PE.fa:2:30:10 LEADING:25 TRAILING:25 SLIDINGWINDOW:4:15 MINLEN:149; done < filenames_trim


# QC trimmed fq.gz files again. This time they have been trimmed and should look different from before.
while read p; do fastqc "$p"_paired.fq.gz; done < filenames



######## Normalize read numbers from multiple fastq files
# Compute the number of reads in each fq.gz file
while read p; do gunzip -c "$p"_paired.fq.gz | wc -l | awk '{print $1 / 4}' >> numreads; done < filenames

# Compute the minimum number of reads across all fq in the folder
minreads=$(cat numreads | sort -n | head -1)

#subsample fq.gz files
while read p; do seqtk sample -s100 "$p"_paired.fq.gz $minreads | gzip > "$p".sub.fastq.gz; done < filenames


######## Bowtie2 alignment pipeline
# first pipe: runs alignment of fq.gz to database, creates .sam file, extracts and outputs only mapped/aligned reads
# second pipe: converts .sam to .bam
# third pipe: sorts the bam file in order of database sequence appearance

while read p; do bowtie2 --threads 2 -x ICE_db -1 "$p"_R1.sub.fastq.gz -2 "$p"_R2.sub.fastq.gz --no-unal | samtools view -bS - | samtools sort -o - > "$p"_ICE.bam; done < filenames_trim

while read p; do bowtie2 --threads 2 -x ARG_db -1 "$p"_R1.sub.fastq.gz -2 "$p"_R2.sub.fastq.gz --no-unal | samtools view -bS - | samtools sort -o - > "$p"_ARG.bam; done < filenames_trim


######## create comparison plots of mapped reads

# create table of total mapped reads in each sample  
while read p; do mapped=$(samtools view -c -F 4 ${p}_ICE.bam); printf "$p\t$mapped\n"; done < filenames_trim > ICE-mapped.tsv 

while read p; do mapped=$(samtools view -c -F 4 ${p}_ARG.bam); printf "$p\t$mapped\n"; done < filenames_trim > ARG-mapped.tsv 


# create barplot to compare TOTAL mapped reads across samples
gnuplot -e "set terminal png size 640,300; set output 'ICE_mapped_read_barplot.png'; set boxwidth 0.4; set style fill solid 1.00; set terminal png nocrop enhanced font 'verdana,10' size 640,300; set nokey; set title 'ICE Mapped Reads'; set ylabel 'Mapped Reads'; plot 'ICE-mapped.tsv' using 2:xticlabels(1) with boxes lt rgb '#406090'"

gnuplot -e "set terminal png size 640,300; set output 'ARG_mapped_read_barplot.png'; set boxwidth 0.4; set style fill solid 1.00; set terminal png nocrop enhanced font 'verdana,10' size 640,300; set nokey; set title 'ARG Mapped Reads'; set ylabel 'Mapped Reads'; plot 'ARG-mapped.tsv' using 2:xticlabels(1) with boxes lt rgb '#406090'"


############Construction Zone Below#############


## create coverage table with one column as [base location] and another column [coverage at that base]###
while read p; do genomeCoverageBed -d -ibam "$p".bam | awk '{$1=""}1' - | awk '{$1=$1}1' > "$p".coverage.tsv; done < filenames



### HMM Meta-Mark ##
mmarc --i1 *1.fq.gz --i2 *2.fq.gz -o day_9_mmarc -f day_9_mmarc -d -l 3 -m -t 4

mmarc -i  -o mmarc -f day_9_mmarc -d -l 3 -m -t 4




